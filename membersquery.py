# Finds an intersection between users in different groups
# Copyright Â© 2024 https://t.me/nalinor

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# meta developer: @nalinormods

# Even taking into account the fact I double-checked every math expression,
# you, as a reader, have to remember that I'm a programmer, not a math expert.
# Some complicated operations (like symmetric difference on the complement of a set) may go wrong.
# I'd be glad to see your pull requests here if you find an error.

# Reminder: In the code below I use "negated" and "negatable" sets as a definition for "the complement of a set".
# It's easier for me to say that a set is "negated" rather than a set is "complement", "completion", "completed", ...

import ast
import io
import logging
import time
from typing import cast

from telethon import TelegramClient, errors
from telethon.errors import ChatAdminRequiredError
from telethon.hints import Entity
from telethon.tl import types
from telethon.tl.custom import Message
from telethon.tl.functions.channels import JoinChannelRequest

from .. import loader, utils

logger = logging.getLogger(__name__)


class InvalidChatID(Exception):
    def __init__(self, chat_id: "int | str", reason: str):
        self.chat_id = chat_id
        self.reason = reason

    def __str__(self):
        return f"Invalid chat ID {self.chat_id}: {self.reason}"


class NegatableSet(set):
    """
    Set that can be negated.
    Negated set A is a set of all elements that are not in A (a complement of set A).

    https://en.wikipedia.org/wiki/Complement_(set_theory)
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.negated = False

    def __invert__(self):
        """Creates a copy of set and marks it as negated"""
        return NegatableSet(self).negate()

    def negate(self) -> "NegatableSet":
        """Marks that the set is negated in-place"""
        self.negated = not self.negated
        return self

    def __and__(self, other: "NegatableSet") -> "NegatableSet":
        if self.negated and other.negated:
            return NegatableSet(self.union(other)).negate()

        if other.negated:
            return NegatableSet(self.difference(other))

        if self.negated:
            return NegatableSet(other.difference(self))

        return NegatableSet(self.intersection(other))

    def __or__(self, other: "NegatableSet") -> "NegatableSet":
        if self.negated and other.negated:
            return NegatableSet(self.intersection(other)).negate()

        if other.negated:
            return NegatableSet(other.difference(self)).negate()

        if self.negated:
            return NegatableSet(self.difference(other)).negate()

        return NegatableSet(self.union(other))

    def __sub__(self, other: "NegatableSet") -> "NegatableSet":
        if self.negated and other.negated:
            return NegatableSet(self.difference(other))

        if other.negated:
            return NegatableSet(self.intersection(other))

        if self.negated:
            return NegatableSet(self.union(other)).negate()

        return NegatableSet(self.difference(other))

    def __xor__(self, other: "NegatableSet") -> "NegatableSet":
        if self.negated and other.negated:
            # (A - B) | (B - A)
            return NegatableSet(self.difference(other).union(other.difference(self)))

        if self.negated or other.negated:
            # (A & B) | ~(A | B)
            # => ~((A - B) | (B - A))
            return NegatableSet(
                self.difference(other).union(other.difference(self))
            ).negate()

        return NegatableSet(self.symmetric_difference(other))

    def __ior__(self, other):
        raise NotImplementedError("use __or__ instead")

    def __iand__(self, other):
        raise NotImplementedError("use __and__ instead")


class QueryExecutor:
    async def fetch_set(self, key: "int | str") -> NegatableSet:
        """Fetches a set to be used in a query"""

        raise NotImplementedError

    async def execute(self, query: str) -> NegatableSet:
        """Executes a query"""

        query = query.replace("&&", "&").replace("||", "|").replace("@", "")

        body = ast.parse(query).body

        if not body:
            raise SyntaxError("empty body")
        if len(body) > 1:
            raise SyntaxError("more than one statement in the body")
        if not isinstance(body[0], ast.Expr):
            raise SyntaxError(
                f"expected expression, {body[0].__class__.__name__} found"
            )

        expr = cast(ast.Expr, body[0])
        result = await self.query(expr.value)

        return result

    async def execute_simplified(self, params: "list[str]") -> NegatableSet:
        first = await self.fetch_set(params[0])
        for param in params[1:]:
            first = first & await self.fetch_set(param)
        return first

    async def query(self, expr: ast.expr) -> NegatableSet:
        """Recursively iterates over the expression tree and evaluates it"""
        if isinstance(expr, ast.Name):
            return await self.fetch_set(expr.id)

        if isinstance(expr, ast.Constant):
            if isinstance(expr.value, (str, int)):
                return await self.fetch_set(expr.value)

            raise SyntaxError(f"invalid constant value: {expr.value}")

        if (
            isinstance(expr, ast.UnaryOp)
            and isinstance(expr.op, ast.USub)
            and isinstance(expr.operand, ast.Constant)
        ):
            if isinstance(expr.operand.value, int):
                return await self.fetch_set(-expr.operand.value)

            raise SyntaxError(f"invalid constant value: {expr.operand.value}")

        if isinstance(expr, ast.BoolOp):
            first = await self.query(expr.values[0])

            for value in expr.values[1:]:
                if isinstance(expr.op, ast.And):
                    first = first & await self.query(value)
                else:
                    first = first | await self.query(value)

            return first

        if isinstance(expr, ast.BinOp):
            if isinstance(expr.op, ast.BitAnd):
                return await self.query(expr.left) & await self.query(expr.right)

            if isinstance(expr.op, (ast.BitOr, ast.Add)):
                return await self.query(expr.left) | await self.query(expr.right)

            if isinstance(expr.op, ast.Sub):
                return await self.query(expr.left) - await self.query(expr.right)

            if isinstance(expr.op, ast.BitXor):
                return await self.query(expr.left) ^ await self.query(expr.right)

        if isinstance(expr, ast.UnaryOp) and isinstance(
            expr.op,
            (
                ast.Not,
                ast.Invert,
                ast.USub,
            ),
        ):
            return (await self.query(expr.operand)).negate()

        logger.debug("remaining expression: %s", ast.dump(expr))
        raise SyntaxError(f"operator {expr.__class__.__name__} is not supported")


members_cache: "dict[int | str, tuple[dict[int], float]]" = {}


class UsersQueryExecutor(QueryExecutor):
    def __init__(self, client: TelegramClient):
        super().__init__()

        self.users: "dict[int]" = {}
        self.client = client

    async def fetch_set(self, key: "int | str") -> NegatableSet:
        if key in ["me", "self"]:
            me = await self.client.get_me()
            self.users[me.id] = me

            return NegatableSet([me.id])

        try:
            key = int(key)
        except ValueError:
            pass

        try:
            chat = await self.client.get_entity(await self.client.get_input_entity(key))
        except (ValueError, errors.BadRequestError) as e:
            raise InvalidChatID(key, str(e))

        if isinstance(chat, types.User):
            raise InvalidChatID(key, "chat ID belongs to a user")

        if key in members_cache and members_cache[key][1] > time.perf_counter():
            logger.debug("Using cached participants for %s", key)
            members = members_cache[key][0]
        else:
            logger.debug("Fetching participants for %s", key)
            try:
                members = {
                    member.id: member
                    async for member in self.client.iter_participants(chat.id)
                }
            except ChatAdminRequiredError:
                raise InvalidChatID(
                    key, "insufficient privileges to view users in chat"
                )

            members_cache[key] = (members, time.perf_counter() + 600)

        self.users.update(members)

        return NegatableSet(members.keys())


def format_user(user: Entity, tags: bool = True) -> str:
    """Formats a user to be displayed in the results"""
    if user.username:
        link, username = f"https://t.me/{user.username}", f"@{user.username}"
    elif user.usernames:
        username = user.usernames[0].username
        link, username = f"https://t.me/{username}", f"@{username}"
    else:
        link, username = f"tg://user?id={user.id}", ""

    name = (
        f"{user.first_name} {user.last_name}"
        if user.last_name
        else user.first_name
        if user.first_name
        else "Deleted Account"
    )

    if tags:
        name = utils.escape_html(name)
        return f"<a href='{link}'>{name}</a> (<code>{user.id}</code>)"

    return f"{user.id} {name} {username}"


# noinspection PyCallingNonCallable,PyAttributeOutsideInit
# pylint: disable=not-callable,attribute-defined-outside-init,invalid-name
@loader.tds
class MembersQueryMod(loader.Module):
    """Finds an intersection between members of different groups"""

    strings = {
        "name": "MembersQuery",
        "author": "@nalinormods",
        "usage": """
ð <b>MembersQuery module syntax</b>

A brief of Python syntax is used for queries.

Specify groups as a username (with or without @) or chat ID.
Channels are also accepted in case you are an admin. You can't fetch more than 200 members from a channel, so results may be incomplete.
Specify yourself as <code>me</code> or <code>self</code>.

Each group is represented by a set of its members (see set theory). You can use these operations:
<code>&</code>, <code>and</code> â intersection (members that are in both groups <b>at same time</b>)
<code>|</code>, <code>or</code>, <code>+</code> â union (members of A, B or both groups)
<code>-</code> â difference (members of A group that are not in B group)
<code>^</code> â symmetric difference (members of A or B group, but not both)
<code>~</code>, <code>not</code>, unary <code>-</code> â negation (specifies a group that anybody joined except members of the group)

<b>Examples</b>:
<code>@mymusicgroup and @mychessgroup</code> â members of both groups at same time
<code>@nalinormods & ~@nalinormodschat</code> â subscribers of a channel that didn't join a group yet
<code>hikka_ub | hikka_talks | hikka_offtop</code> â members of any of these groups
<code>-1001234567890 - me</code> â members of a private group except yourself

â¹ï¸ In order to increase performance, the module caches the list of members for 10 minutes. Reload the module or restart the userbot to clear the cache.
""",
        "no_args": "â <b>Specify at least one group</b>",
        "syntax_error": (
            "â <b>You have an syntax error in query"
            " <code>{query}</code>:</b>\n<code>{error}</code>"
        ),
        "invalid_chat_id": "â <b>Invalid chat ID {chat_id}:</b>\n<code>{error}</code>",
        "running": "ð <b>Executing query <code>{query}</code>...</b>",
        "no_results": "ð« <b>No results found</b> for query <code>{query}</code>",
        "results": "ð <b>{n} users found</b> for query <code>{query}</code>",
        "results_file": "ð¤ <b>The list is too long, so it's sent in file.</b>",
        "result_is_negated": (
            "â ï¸ <b>The final set is negated, so result may be incomplete. "
            "Rewrite your query to get accurate results</b>"
        ),
    }

    strings_ru = {
        "_cls_doc": (
            "ÐÐ¾Ð¸ÑÐº Ð¿ÐµÑÐµÑÐµÑÐµÐ½Ð¸Ñ Ð³ÑÑÐ¿Ð¿ Ð½Ð° Ð¿ÑÐµÐ´Ð¼ÐµÑ Ð½Ð°Ð»Ð¸ÑÐ¸Ñ Ð¾Ð´Ð½Ð¸Ñ Ð¸ ÑÐµÑ Ð¶Ðµ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹"
        ),
        "_cmd_doc_mjoin": (
            "<ÑÐ·ÐµÑÐ½ÐµÐ¹Ð¼/ID Ð³ÑÑÐ¿Ð¿Ñ> ... â ÐÐ°Ð¹ÑÐ¸ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð½Ð°ÑÐ¾Ð´ÑÑÑÑ Ð²Ð¾ Ð²ÑÐµÑ"
            " Ð·Ð°Ð´Ð°Ð½Ð½ÑÑ Ð³ÑÑÐ¿Ð¿Ð°Ñ Ð¾Ð´Ð½Ð¾Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¾"
        ),
        "_cmd_doc_mquery": (
            "<Ð·Ð°Ð¿ÑÐ¾Ñ?> â ÐÐ°Ð¹ÑÐ¸ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹ Ð¸Ð· Ð³ÑÑÐ¿Ð¿ Ð¿Ð¾ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¼Ñ Ð·Ð°Ð¿ÑÐ¾ÑÑ. ÐÑÐ·Ð¾Ð²Ð¸ Ð±ÐµÐ·"
            " Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð² Ð´Ð»Ñ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð´Ð»Ñ ÑÐ¿ÑÐ°Ð²ÐºÐ¸."
        ),
        "usage": """
ð <b>Ð¡Ð¸Ð½ÑÐ°ÐºÑÐ¸Ñ Ð¼Ð¾Ð´ÑÐ»Ñ MembersQuery</b>

ÐÐ»Ñ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ ÑÐ°ÑÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ° Python.

Ð§ÑÐ¾Ð±Ñ ÑÐºÐ°Ð·Ð°ÑÑ Ð³ÑÑÐ¿Ð¿Ñ, Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ Ð¸Ñ ÑÐ·ÐµÑÐ½ÐµÐ¹Ð¼ (Ñ Ð¸Ð»Ð¸ Ð±ÐµÐ· @) Ð¸Ð»Ð¸ ID ÑÐ°ÑÐ°.
Ð¢Ð°ÐºÐ¶Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐºÐ°Ð·Ð°ÑÑ ÐºÐ°Ð½Ð°Ð», Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ ÑÑ ÑÐ²Ð»ÑÐµÑÑÑÑ Ð°Ð´Ð¼Ð¸Ð½Ð¾Ð¼. Ð ÐºÐ°Ð½Ð°Ð»Ðµ ÐµÑÑÑ Ð»Ð¸Ð¼Ð¸Ñ Ð½Ð° Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ Ð¼Ð°ÐºÑ. 200 Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹, Ð¿Ð¾ÑÑÐ¾Ð¼Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÑ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð½ÐµÐ¿Ð¾Ð»Ð½ÑÐ¼Ð¸.
Ð§ÑÐ¾Ð±Ñ ÑÐºÐ°Ð·Ð°ÑÑ ÑÐµÐ±Ñ, Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ <code>me</code> Ð¸Ð»Ð¸ <code>self</code>.

ÐÐ°Ð¶Ð´Ð°Ñ Ð³ÑÑÐ¿Ð¿Ð° Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ð° Ð² Ð²Ð¸Ð´Ðµ Ð¼Ð½Ð¾Ð¶ÐµÑÑÐ²Ð° ÐµÑ ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¾Ð² (ÑÐ¼. ÑÐµÐ¾ÑÐ¸Ð¼Ñ Ð¼Ð½Ð¾Ð¶ÐµÑÑÐ²). ÐÐ¾ÑÑÑÐ¿Ð½Ñ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸:
<code>&</code>, <code>and</code> â Ð¿ÐµÑÐµÑÐµÑÐµÐ½Ð¸Ðµ (ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð¸ Ð¿ÐµÑÐ²Ð¾Ð¹, Ð¸ Ð²ÑÐ¾ÑÐ¾Ð¹ Ð³ÑÑÐ¿Ð¿Ñ <b>Ð¾Ð´Ð½Ð¾Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¾</b>)
<code>|</code>, <code>or</code>, <code>+</code> â Ð¾Ð±ÑÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ (ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð¿ÐµÑÐ²Ð¾Ð¹, Ð²ÑÐ¾ÑÐ¾Ð¹ Ð¸Ð»Ð¸ Ð¾Ð±ÐµÐ¸Ñ Ð³ÑÑÐ¿Ð¿)
<code>-</code> â ÑÐ°Ð·Ð½Ð¾ÑÑÑ (ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð¿ÐµÑÐ²Ð¾Ð¹ Ð³ÑÑÐ¿Ð¿Ñ, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð½Ðµ Ð½Ð°ÑÐ¾Ð´ÑÑÑÑ Ð²Ð¾ Ð²ÑÐ¾ÑÐ¾Ð¹)
<code>^</code> â ÑÐ¸Ð¼Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ°Ñ ÑÐ°Ð·Ð½Ð¾ÑÑÑ (ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð¿ÐµÑÐ²Ð¾Ð¹ Ð¸Ð»Ð¸ Ð²ÑÐ¾ÑÐ¾Ð¹ Ð³ÑÑÐ¿Ð¿Ñ, Ð½Ð¾ Ð½Ðµ Ð¾Ð±ÐµÐ¸Ñ)
<code>~</code>, <code>not</code>, <code>-</code> â Ð¾ÑÑÐ¸ÑÐ°Ð½Ð¸Ðµ (Ð¾Ð±Ð¾Ð·Ð½Ð°ÑÐ°ÐµÑ ÑÑÐ»Ð¾Ð²Ð½ÑÑ Ð³ÑÑÐ¿Ð¿Ñ, Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ Ð½Ð°ÑÐ¾Ð´ÑÑÑÑ Ð²ÑÐµ, ÐºÑÐ¾Ð¼Ðµ ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¾Ð² Ð³ÑÑÐ¿Ð¿Ñ)

<b>ÐÑÐ¸Ð¼ÐµÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ</b>:
<code>@mymusicgroup and @mychessgroup</code> â ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð¾Ð±ÐµÐ¸Ñ Ð³ÑÑÐ¿Ð¿ Ð¾Ð´Ð½Ð¾Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¾
<code>@nalinormods & ~@nalinormodschat</code> â Ð¿Ð¾Ð´Ð¿Ð¸ÑÑÐ¸ÐºÐ¸ ÐºÐ°Ð½Ð°Ð»Ð°, ÐºÐ¾ÑÐ¾ÑÑÐµ ÐµÑÑ Ð½Ðµ Ð²ÑÑÑÐ¿Ð¸Ð»Ð¸ Ð² Ð³ÑÑÐ¿Ð¿Ñ
<code>hikka_ub | hikka_talks | hikka_offtop</code> â ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð»ÑÐ±Ð¾Ð¹ Ð¸Ð· ÑÑÐ¸Ñ Ð³ÑÑÐ¿Ð¿
<code>-1001234567890 - me</code> â ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¸ Ð¿ÑÐ¸Ð²Ð°ÑÐ½Ð¾Ð¹ Ð³ÑÑÐ¿Ð¿Ñ, ÐºÑÐ¾Ð¼Ðµ ÑÐµÐ±Ñ

â¹ï¸ Ð ÑÐµÐ»ÑÑ Ð¿ÑÐ¾Ð¸Ð·Ð²Ð¾Ð´Ð¸ÑÐµÐ»ÑÐ½Ð¾ÑÑÐ¸, Ð¼Ð¾Ð´ÑÐ»Ñ ÐºÑÑÐ¸ÑÑÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÐ°ÑÑÐ½Ð¸ÐºÐ¾Ð² Ð½Ð° 10 Ð¼Ð¸Ð½ÑÑ. ÐÐµÑÐµÐ·Ð°Ð³ÑÑÐ·Ð¸ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ñ Ð¸Ð»Ð¸ Ð²ÐµÑÑ ÑÐ·ÐµÑÐ±Ð¾Ñ, ÑÑÐ¾Ð±Ñ Ð¾ÑÐ¸ÑÑÐ¸ÑÑ ÐºÑÑ.
        """,
        "no_args": "â <b>Ð£ÐºÐ°Ð¶Ð¸ÑÐµ ÑÐ¾ÑÑ Ð±Ñ Ð¾Ð´Ð½Ñ Ð³ÑÑÐ¿Ð¿Ñ</b>",
        "syntax_error": (
            "â <b>Ð Ð·Ð°Ð¿ÑÐ¾ÑÐµ <code>{query}</code> ÐµÑÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ°Ñ"
            " Ð¾ÑÐ¸Ð±ÐºÐ°:</b>\n<code>{error}</code>"
        ),
        "invalid_chat_id": (
            "â <b>ÐÐµÐ²ÐµÑÐ½ÑÐ¹ ID/ÑÐ·ÐµÑÐ½ÐµÐ¹Ð¼ ÑÐ°ÑÐ° {chat_id}:</b>\n<code>{error}</code>"
        ),
        "running": "ð <b>ÐÐ°Ð¿ÑÐ¾Ñ <code>{query}</code> Ð²ÑÐ¿Ð¾Ð»Ð½ÑÐµÑÑÑ...</b>",
        "no_results": "ð« <b>Ð ÐµÐ·ÑÐ»ÑÑÐ°ÑÑ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ</b> Ð¿Ð¾ Ð·Ð°Ð¿ÑÐ¾ÑÑ <code>{query}</code>",
        "results": (
            "ð <b>ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾: {n}</b> Ð¿Ð¾ Ð·Ð°Ð¿ÑÐ¾ÑÑ <code>{query}</code>"
        ),
        "results_file": (
            "ð¤ <b>ÐÐ¾Ð»ÑÑÐµÐ½Ð½ÑÐ¹ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ»Ð¸ÑÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑÑÐ¾Ð¹, Ð¿Ð¾ÑÑÐ¾Ð¼Ñ Ð¾Ð½ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½ Ð² ÑÐ°Ð¹Ð»Ðµ.</b>"
        ),
        "result_is_negated": (
            "â ï¸ <b>Ð ÐµÐ·ÑÐ»ÑÑÐ°Ñ Ð¿Ð¾Ð»ÑÑÐµÐ½ Ð¸Ð· Ð¾ÑÑÐ¸ÑÐ°ÑÐµÐ»ÑÐ½Ð¾Ð³Ð¾ Ð¼Ð½Ð¾Ð¶ÐµÑÑÐ²Ð°, Ð¿Ð¾ÑÑÐ¾Ð¼Ñ Ð¾Ð½ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ"
            " Ð½ÐµÐ¿Ð¾Ð»Ð½ÑÐ¼. ÐÑÐ¿ÑÐ°Ð²Ñ Ð·Ð°Ð¿ÑÐ¾Ñ, ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÑÐ¾ÑÐ½ÑÐ¹ ÑÐµÐ·ÑÐ»ÑÑÐ°Ñ</b>"
        ),
    }

    async def client_ready(self, client: TelegramClient, _):
        """client_ready hook"""
        self.client = client

        await client(JoinChannelRequest(channel=self.strings("author")))

    def format_results(
        self, query: str, results: NegatableSet, users: dict
    ) -> (str, "io.BytesIO | None"):
        """Formats results to be displayed in the message"""
        negated = results.negated
        if negated:
            results = set(users.keys()).difference(results)

        if not results:
            return self.strings("no_results").format(query=query), None

        text = self.strings("results").format(query=query, n=len(results)) + "\n\n"

        use_file = len(results) > 30
        formatted_results = (
            format_user(users[user_id], tags=not use_file) for user_id in results
        )

        if use_file:
            text += self.strings("results_file") + "\n\n"

            stream = io.BytesIO()
            stream.write("\n".join(formatted_results).encode("utf-8"))
            stream.seek(0)
            stream.name = "result.txt"
        else:
            text += "\n".join(formatted_results) + "\n\n"
            stream = None

        if negated:
            text += self.strings("result_is_negated")

        return text, stream

    async def mjoincmd(self, message: Message):
        """<username/chat ID> ... â Find users that are in all given chats at same time"""
        text = utils.get_args_raw(message)
        if not text:
            return await utils.answer(message, self.strings("no_args"))

        await self.mquerycmd(message, simplified=True)

    async def mquerycmd(self, message: Message, simplified: bool = False):
        """<query?> â Find users from given chats that match the query. Call without args for help."""
        text = utils.get_args_raw(message)
        if not text:
            return await utils.answer(message, self.strings("usage"))

        m = await utils.answer(message, self.strings("running").format(query=text))
        if isinstance(m, list):
            m = m[0]

        executor = UsersQueryExecutor(self.client)

        try:
            if simplified:
                result = await executor.execute_simplified(text.split())
            else:
                result = await executor.execute(text)
        except SyntaxError as e:
            await utils.answer(
                m, self.strings("syntax_error").format(error=e, query=text)
            )
            return
        except InvalidChatID as e:
            await utils.answer(
                m,
                self.strings("invalid_chat_id").format(
                    chat_id=e.chat_id, error=e.reason
                ),
            )
            return

        text, stream = self.format_results(text, result, executor.users)

        if stream:
            await self.client.send_file(
                message.chat_id,
                stream,
                caption=text,
                reply_to=message.reply_to_msg_id,
            )
            await m.delete()
        else:
            await utils.answer(m, text)
